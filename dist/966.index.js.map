{"version":3,"file":"966.index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././node_modules/rate-limiter-flexible/lib/ExpressBruteFlexible.js",".././node_modules/rate-limiter-flexible/lib/constants.js"],"sourcesContent":["const {\n  LIMITER_TYPES,\n  ERR_UNKNOWN_LIMITER_TYPE_MESSAGE,\n} = require('./constants');\nconst crypto = require('crypto');\nconst {\n  RateLimiterMemory,\n  RateLimiterCluster,\n  RateLimiterMemcache,\n  RateLimiterMongo,\n  RateLimiterMySQL,\n  RateLimiterPostgres,\n  RateLimiterRedis,\n  RateLimiterValkey,\n  RateLimiterValkeyGlide,\n} = require('../index');\n\nfunction getDelayMs(count, delays, maxWait) {\n  let msDelay = maxWait;\n  const delayIndex = count - 1;\n  if (delayIndex >= 0 && delayIndex < delays.length) {\n    msDelay = delays[delayIndex];\n  }\n\n  return msDelay;\n}\n\nconst ExpressBruteFlexible = function (limiterType, options) {\n  ExpressBruteFlexible.instanceCount++;\n  this.name = `brute${ExpressBruteFlexible.instanceCount}`;\n\n  this.options = Object.assign({}, ExpressBruteFlexible.defaults, options);\n  if (this.options.minWait < 1) {\n    this.options.minWait = 1;\n  }\n\n  const validLimiterTypes = Object.keys(ExpressBruteFlexible.LIMITER_TYPES).map(k => ExpressBruteFlexible.LIMITER_TYPES[k]);\n  if (!validLimiterTypes.includes(limiterType)) {\n    throw new Error(ERR_UNKNOWN_LIMITER_TYPE_MESSAGE);\n  }\n  this.limiterType = limiterType;\n\n  this.delays = [this.options.minWait];\n  while (this.delays[this.delays.length - 1] < this.options.maxWait) {\n    const nextNum = this.delays[this.delays.length - 1] + (this.delays.length > 1 ? this.delays[this.delays.length - 2] : 0);\n    this.delays.push(nextNum);\n  }\n  this.delays[this.delays.length - 1] = this.options.maxWait;\n\n  // set default lifetime\n  if (typeof this.options.lifetime === 'undefined') {\n    this.options.lifetime = Math.ceil((this.options.maxWait / 1000) * (this.delays.length + this.options.freeRetries));\n  }\n\n  this.prevent = this.getMiddleware({\n    prefix: this.options.prefix,\n  });\n};\n\nExpressBruteFlexible.prototype.getMiddleware = function (options) {\n  const opts = Object.assign({}, options);\n  const commonKeyPrefix = opts.prefix || '';\n  const freeLimiterOptions = {\n    storeClient: this.options.storeClient,\n    storeType: this.options.storeType,\n    keyPrefix: `${commonKeyPrefix}free`,\n    dbName: this.options.dbName,\n    tableName: this.options.tableName,\n    points: this.options.freeRetries > 0 ? this.options.freeRetries - 1 : 0,\n    duration: this.options.lifetime,\n  };\n\n  const blockLimiterOptions = {\n    storeClient: this.options.storeClient,\n    storeType: this.options.storeType,\n    keyPrefix: `${commonKeyPrefix}block`,\n    dbName: this.options.dbName,\n    tableName: this.options.tableName,\n    points: 1,\n    duration: Math.min(this.options.lifetime, Math.ceil((this.options.maxWait / 1000))),\n  };\n\n  const counterLimiterOptions = {\n    storeClient: this.options.storeClient,\n    storeType: this.options.storeType,\n    keyPrefix: `${commonKeyPrefix}counter`,\n    dbName: this.options.dbName,\n    tableName: this.options.tableName,\n    points: 1,\n    duration: this.options.lifetime,\n  };\n\n  switch (this.limiterType) {\n    case 'memory':\n      this.freeLimiter = new RateLimiterMemory(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterMemory(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterMemory(counterLimiterOptions);\n      break;\n    case 'cluster':\n      this.freeLimiter = new RateLimiterCluster(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterCluster(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterCluster(counterLimiterOptions);\n      break;\n    case 'memcache':\n      this.freeLimiter = new RateLimiterMemcache(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterMemcache(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterMemcache(counterLimiterOptions);\n      break;\n    case 'mongo':\n      this.freeLimiter = new RateLimiterMongo(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterMongo(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterMongo(counterLimiterOptions);\n      break;\n    case 'mysql':\n      this.freeLimiter = new RateLimiterMySQL(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterMySQL(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterMySQL(counterLimiterOptions);\n      break;\n    case 'postgres':\n      this.freeLimiter = new RateLimiterPostgres(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterPostgres(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterPostgres(counterLimiterOptions);\n      break;\n    case 'valkey-glide':\n      this.freeLimiter = new RateLimiterValkeyGlide(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterValkeyGlide(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterValkeyGlide(counterLimiterOptions);\n      break;\n    case 'valkey':\n      this.freeLimiter = new RateLimiterValkey(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterValkey(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterValkey(counterLimiterOptions);\n      break;\n    case 'redis':\n      this.freeLimiter = new RateLimiterRedis(freeLimiterOptions);\n      this.blockLimiter = new RateLimiterRedis(blockLimiterOptions);\n      this.counterLimiter = new RateLimiterRedis(counterLimiterOptions);\n      break;\n    default:\n      throw new Error(ERR_UNKNOWN_LIMITER_TYPE_MESSAGE);\n  }\n\n  let keyFunc = opts.key;\n  if (typeof keyFunc !== 'function') {\n    keyFunc = function (req, res, next) {\n      next(opts.key);\n    };\n  }\n\n  const getFailCallback = (() => (typeof opts.failCallback === 'undefined' ? this.options.failCallback : opts.failCallback));\n\n  return (req, res, next) => {\n    const cannotIncrementErrorObjectBase = {\n      req,\n      res,\n      next,\n      message: 'Cannot increment request count',\n    };\n\n    keyFunc(req, res, (key) => {\n      if (!opts.ignoreIP) {\n        key = ExpressBruteFlexible._getKey([req.ip, this.name, key]);\n      } else {\n        key = ExpressBruteFlexible._getKey([this.name, key]);\n      }\n\n      // attach a simpler \"reset\" function to req.brute.reset\n      if (this.options.attachResetToRequest) {\n        let reset = ((callback) => {\n          Promise.all([\n            this.freeLimiter.delete(key),\n            this.blockLimiter.delete(key),\n            this.counterLimiter.delete(key),\n          ]).then(() => {\n            if (typeof callback === 'function') {\n              process.nextTick(() => {\n                callback();\n              });\n            }\n          }).catch((err) => {\n            if (typeof callback === 'function') {\n              process.nextTick(() => {\n                callback(err);\n              });\n            }\n          });\n        });\n\n        if (req.brute && req.brute.reset) {\n          // wrap existing reset if one exists\n          const oldReset = req.brute.reset;\n          const newReset = reset;\n          reset = function (callback) {\n            oldReset(() => {\n              newReset(callback);\n            });\n          };\n        }\n        req.brute = {\n          reset,\n        };\n      }\n\n      this.freeLimiter.consume(key)\n        .then(() => {\n          if (typeof next === 'function') {\n            next();\n          }\n        })\n        .catch(() => {\n          Promise.all([\n            this.blockLimiter.get(key),\n            this.counterLimiter.get(key),\n          ])\n            .then((allRes) => {\n              const [blockRes, counterRes] = allRes;\n\n              if (blockRes === null) {\n                const msDelay = getDelayMs(\n                  counterRes ? counterRes.consumedPoints + 1 : 1,\n                  this.delays,\n                  // eslint-disable-next-line\n                  this.options.maxWait\n                );\n\n                this.blockLimiter.penalty(key, 1, { customDuration: Math.ceil(msDelay / 1000) })\n                  .then((blockPenaltyRes) => {\n                    if (blockPenaltyRes.consumedPoints === 1) {\n                      this.counterLimiter.penalty(key)\n                        .then(() => {\n                          if (typeof next === 'function') {\n                            next();\n                          }\n                        })\n                        .catch((err) => {\n                          this.options.handleStoreError(Object.assign({}, cannotIncrementErrorObjectBase, { parent: err }));\n                        });\n                    } else {\n                      const nextValidDate = new Date(Date.now() + blockPenaltyRes.msBeforeNext);\n\n                      const failCallback = getFailCallback();\n                      if (typeof failCallback === 'function') {\n                        failCallback(req, res, next, nextValidDate);\n                      }\n                    }\n                  })\n                  .catch((err) => {\n                    this.options.handleStoreError(Object.assign({}, cannotIncrementErrorObjectBase, { parent: err }));\n                  });\n              } else {\n                const nextValidDate = new Date(Date.now() + blockRes.msBeforeNext);\n\n                const failCallback = getFailCallback();\n                if (typeof failCallback === 'function') {\n                  failCallback(req, res, next, nextValidDate);\n                }\n              }\n            })\n            .catch((err) => {\n              this.options.handleStoreError(Object.assign({}, cannotIncrementErrorObjectBase, { parent: err }));\n            });\n        });\n    });\n  };\n};\n\nExpressBruteFlexible.prototype.reset = function (ip, key, callback) {\n  let keyArgs = [];\n  if (ip) {\n    keyArgs.push(ip)\n  }\n  keyArgs.push(this.name);\n  keyArgs.push(key);\n  const ebKey = ExpressBruteFlexible._getKey(keyArgs);\n\n  Promise.all([\n    this.freeLimiter.delete(ebKey),\n    this.blockLimiter.delete(ebKey),\n    this.counterLimiter.delete(ebKey),\n  ]).then(() => {\n    if (typeof callback === 'function') {\n      process.nextTick(() => {\n        callback();\n      });\n    }\n  }).catch((err) => {\n    this.options.handleStoreError({\n      message: 'Cannot reset request count',\n      parent: err,\n      key,\n      ip,\n    });\n  });\n};\n\nExpressBruteFlexible._getKey = function (arr) {\n  let key = '';\n\n  arr.forEach((part) => {\n    if (part) {\n      key += crypto.createHash('sha256').update(part).digest('base64');\n    }\n  });\n\n  return crypto.createHash('sha256').update(key).digest('base64');\n};\n\nconst setRetryAfter = function (res, nextValidRequestDate) {\n  const secondUntilNextRequest = Math.ceil((nextValidRequestDate.getTime() - Date.now()) / 1000);\n  res.header('Retry-After', secondUntilNextRequest);\n};\nExpressBruteFlexible.FailTooManyRequests = function (req, res, next, nextValidRequestDate) {\n  setRetryAfter(res, nextValidRequestDate);\n  res.status(429);\n  res.send({\n    error: {\n      text: 'Too many requests in this time frame.',\n      nextValidRequestDate,\n    },\n  });\n};\nExpressBruteFlexible.FailForbidden = function (req, res, next, nextValidRequestDate) {\n  setRetryAfter(res, nextValidRequestDate);\n  res.status(403);\n  res.send({\n    error: {\n      text: 'Too many requests in this time frame.',\n      nextValidRequestDate,\n    },\n  });\n};\nExpressBruteFlexible.FailMark = function (req, res, next, nextValidRequestDate) {\n  res.status(429);\n  setRetryAfter(res, nextValidRequestDate);\n  res.nextValidRequestDate = nextValidRequestDate;\n  next();\n};\n\nExpressBruteFlexible.defaults = {\n  freeRetries: 2,\n  attachResetToRequest: true,\n  minWait: 500,\n  maxWait: 1000 * 60 * 15,\n  failCallback: ExpressBruteFlexible.FailTooManyRequests,\n  handleStoreError(err) {\n    // eslint-disable-next-line\n    throw {\n      message: err.message,\n      parent: err.parent,\n    };\n  },\n};\n\nExpressBruteFlexible.LIMITER_TYPES = LIMITER_TYPES;\n\nExpressBruteFlexible.instanceCount = 0;\n\n\nmodule.exports = ExpressBruteFlexible;\n","const LIMITER_TYPES = {\n  MEMORY: 'memory',\n  CLUSTER: 'cluster',\n  MEMCACHE: 'memcache',\n  MONGO: 'mongo',\n  REDIS: 'redis',\n  MYSQL: 'mysql',\n  POSTGRES: 'postgres',\n  DYNAMO: 'dynamo',\n  PRISMA: 'prisma',\n  SQLITE: 'sqlite',\n  VALKEY: 'valkey',\n  VALKEY_GLIDE: 'valkey-glide',\n};\n\nconst ERR_UNKNOWN_LIMITER_TYPE_MESSAGE = 'Unknown limiter type. Use one of LIMITER_TYPES constants.';\n\nmodule.exports = {\n  LIMITER_TYPES,\n  ERR_UNKNOWN_LIMITER_TYPE_MESSAGE,\n};\n"],"names":[],"sourceRoot":""}